# Unit Tests Suite 1

| # | Тестове оточення | Тест | Очікуваний результат | Висновок |
|---|------------------|------|----------------------|----------|
| 1 | Веб-браузер | - Рендеримо компонент `<AuthLayout />` з заголовком "Test Title" і іконкою `<User />`. <br> - Перевіряємо, що текст "Test Title" присутній у документі. <br> - Перевіряємо, що елемент з `data-testid="test-icon"` присутній у документі. <br> - Перевіряємо, що елемент з `data-testid="test-content"` присутній у документі та містить текст "Test Content". | **Рендеринг макету з заголовком та іконкою** | + |
| 2 | Веб-браузер | - Рендеримо компонент `<AuthLayout />` з заголовком "Test Title" і без іконки (`icon={null}`). <br> - Перевіряємо, що текст "Test Title" присутній у документі. <br> - Перевіряємо, що елемент з `data-testid="test-content"` присутній у документі. | **Рендеринг макету без іконки** | + |
| 3 | Веб-браузер | - Рендеримо компонент `<Button />` з текстом "Click Me". <br> - Перевіряємо, що кнопка присутня у документі. <br> - Перевіряємо, що кнопка має клас `bg-indigo-600`. <br> - Перевіряємо, що кнопка не має класу `w-full` і не має атрибуту `disabled`. | **Рендеринг кнопки зі стандартним стилем** | + |
| 4 | Веб-браузер | - Рендеримо компонент `<Button fullWidth />` з текстом "Full Width Button". <br> - Перевіряємо, що кнопка має клас `w-full`. | **Рендеринг кнопки на повну ширину** | + |
| 5 | Веб-браузер | - Рендеримо компонент `<Button disabled />` з текстом "Disabled Button". <br> - Перевіряємо, що кнопка вимкнена (`disabled`). <br> - Перевіряємо наявність класів `opacity-50` та `cursor-not-allowed`. | **Рендеринг вимкненої кнопки** | + |
| 6 | Веб-браузер | - Рендеримо компонент `<Button isLoading />` з текстом "Loading Button". <br> - Перевіряємо, що кнопка вимкнена (`disabled`). <br> - Перевіряємо наявність елемента зі `data-testid="loading-spinner"`. <br> - Перевіряємо, що текст кнопки має клас `opacity-0`. | **Рендеринг кнопки у стані завантаження** | + |
| 7 | Веб-браузер | - Рендеримо компонент `<Button onClick={handleClick} />` з текстом "Clickable Button". <br> - Емітуємо клік по кнопці. <br> - Перевіряємо, що функція `handleClick` була викликана один раз. | **Виклик обробника кліку на кнопці** | + |
| 8 | Веб-браузер | - Рендеримо компонент `<Button onClick={handleClick} disabled />` з текстом "Disabled Button". <br> - Емітуємо клік по кнопці. <br> - Перевіряємо, що функція `handleClick` не була викликана. | **Не викликається обробник кліку на вимкненій кнопці** | + |
| 9 | Веб-браузер | - Рендеримо компонент `<Button onClick={handleClick} isLoading />` з текстом "Loading Button". <br> - Емітуємо клік по кнопці. <br> - Перевіряємо, що функція `handleClick` не була викликана. | **Не викликається обробник кліку під час завантаження кнопки** | + |
| 10 | Веб-браузер | - Рендеримо компонент `<Button type="submit" />` з текстом "Submit Button". <br> - Перевіряємо, що кнопка має атрибут `type="submit"`. | **Рендеринг кнопки з атрибутом типу** | + |
| 11 | Веб-браузер | - Рендеримо компонент `<Button className="custom-class" />` з текстом "Custom Button". <br> - Перевіряємо, що кнопка має клас `custom-class` разом із стандартним класом `bg-indigo-600`. | **Рендеринг кнопки з додатковим класом** | + |
| 12 | Веб-браузер | - Рендеримо компонент `<FormInput />` із `label="Test Label"`, `id="test-input"`, `name="testInput"`, `type="text"`, `value=""`. <br> - Перевіряємо, що текст мітки "Test Label" присутній у документі. <br> - Перевіряємо, що інпут має правильні атрибути (`id`, `name`, `type`). | **Рендеринг інпуту з міткою** | + |
| 13 | Веб-браузер | - Рендеримо компонент `<FormInput />` з переданим значенням `value="Test Value"`. <br> - Перевіряємо, що інпут містить значення "Test Value". | **Відображення значення в інпуті** | + |
| 14 | Веб-браузер | - Рендеримо компонент `<FormInput />` із переданою функцією `onChange`. <br> - Симулюємо введення нового тексту у поле інпуту. <br> - Перевіряємо, що функція `handleChange` була викликана при зміні значення. | **Виклик функції onChange при зміні інпуту** | + |

## Integration Tests Suite 1

| # | Тестове оточення | Тест | Очікуваний результат | Висновок |
|---|------------------|------|----------------------|----------|
| 1 | Веб-браузер | - Рендеримо компонент `<AutomatedTesting />`. <br> - Перевіряємо, що назва мікросервісу відображається на сторінці (текст "Testing: " + назва мікросервісу). <br> - Перевіряємо, що список тестів рендериться, коли мікросервіс має дочірні елементи (текст "Authentication Service"). | **Рендеринг компоненту з назвою мікросервісу та списком тестів** | + |
| 2 | Веб-браузер | - Рендеримо компонент `<AutomatedTesting />`. <br> - Знаходимо кнопку "Run All Tests" за текстом. <br> - Перевіряємо, що кнопка присутня у документі. <br> - Емітуємо клік по кнопці "Run All Tests". <br> - Перевіряємо, що функція `mockShowInfo` викликається з повідомленням "Running 3 tests for Microservice 1...". | **Рендеринг кнопки запуску всіх тестів** | + |
| 3 | Веб-браузер | - Рендеримо компонент `<AutomatedTesting />`. <br> - Знаходимо кнопку перемикання чату за атрибутом aria-label "Hide Test Assistant". <br> - Перевіряємо, що кнопка присутня у документі. <br> - Емітуємо клік по кнопці. <br> - Перевіряємо, що після кліку атрибут aria-label змінюється на "Show Test Assistant". | **Рендеринг кнопки перемикання чату** | + |
| 4 | Веб-браузер | - Рендеримо компонент `<AutomatedTesting />`. <br> - Знаходимо компонент ResizeHandle за роллю 'separator'. <br> - Перевіряємо, що компонент присутній у документі. <br> - Емітуємо подію mouseDown на компоненті ResizeHandle. <br> - Перевіряємо, що функція `mockStartResize` була викликана. | **Рендеринг компоненту ResizeHandle коли чат видимий** | + |
| 5 | Веб-браузер | - Рендеримо компонент `<AutomatedTesting />` з параметром allTestsComplete = true. <br> - Перевіряємо, що функція `mockShowSuccess` була викликана з повідомленням "All tests for Authentication Service have completed". | **Відображення повідомлення про успішне завершення всіх тестів** | + |
| 6 | Веб-браузер | - Рендеримо компонент `<AutomatedTesting />`. <br> - Оскільки ми не можемо безпосередньо протестувати функцію handleGenerateTest, перевіряємо що компонент рендериться без помилок. <br> - Перевіряємо наявність тексту "Testing: " + назва мікросервісу на сторінці. | **Коректна обробка генерації тестів** | + |

## Integration Tests Suite 2

| # | Тестове оточення | Тест | Очікуваний результат | Висновок |
|---|------------------|------|----------------------|----------|
| 1 | Веб-браузер | - Рендеримо компонент `<EmptyState />` без властивостей. <br> - Перевіряємо, що текст "No logs found for this microservice" відображається на сторінці. <br> - Перевіряємо, що текст "Try triggering a pipeline to generate logs." відображається на сторінці. | **Рендеринг з типовим заголовком та повідомленням** | + |
| 2 | Веб-браузер | - Рендеримо компонент `<EmptyState />` з властивостями message="No Tests Found" та description="There are no tests available for this microservice.". <br> - Перевіряємо, що текст "No Tests Found" відображається на сторінці. <br> - Перевіряємо, що текст "There are no tests available for this microservice." відображається на сторінці. | **Рендеринг з користувацьким заголовком та повідомленням** | + |
| 3 | Веб-браузер | - Рендеримо компонент `<EmptyState />`. <br> - Перевіряємо, що іконка (SVG) присутня на сторінці (елемент з data-testid="empty-state-icon"). | **Рендеринг з іконкою** | + |
| 4 | Веб-браузер | - Рендеримо компонент `<EmptyState />`. <br> - Перевіряємо, що контейнер має атрибут role="status" (елемент з data-testid="empty-state-container"). <br> - Перевіряємо, що контейнер має атрибут aria-live="polite". | **Рендеринг з відповідними ARIA атрибутами для доступності** | + |

## Integration Tests Suite 3

| # | Тестове оточення | Тест | Очікуваний результат | Висновок |
|---|------------------|------|----------------------|----------|
| 1 | Веб-браузер | - Рендеримо компонент `<TestList />` з тестовими даними. <br> - Знаходимо кнопку "Expand all functions" через data-testid. <br> - Перевіряємо, що всі тестові елементи мають клас "collapsed". <br> - Емітуємо клік по кнопці "Expand all functions". <br> - Перевіряємо, що функція `mockExpandAll` була викликана. <br> - Перевіряємо, що функція `mockShowInfo` була викликана з параметром "All tests expanded". <br> - Виконуємо повторне рендерингу компоненту, щоб відобразити зміни стану. <br> - Перевіряємо, що всі тестові елементи тепер мають клас "expanded". <br> - Перевіряємо, що діти тестового елемента з ідентифікатором "func1" тепер видимі (елемент з data-testid="children-func1"). <br> - Перевіряємо, що кнопки розгортання тепер мають текст "Collapse". | **Розгортання всіх елементів при натисканні на кнопку "Expand all functions"** | + |
| 2 | Веб-браузер | - Рендеримо компонент `<TestList />` з розгорнутими тестовими елементами. <br> - Перевіряємо, що всі тестові елементи мають клас "expanded". <br> - Знаходимо кнопку "Collapse all" через data-testid. <br> - Емітуємо клік по кнопці "Collapse all". <br> - Перевіряємо, що функція `mockCollapseAll` була викликана. <br> - Виконуємо повторне рендерингу компоненту, щоб відобразити зміни стану. <br> - Перевіряємо, що всі тестові елементи тепер мають клас "collapsed". <br> - Перевіряємо, що діти тестових елементів тепер не видимі. <br> - Перевіряємо, що кнопки розгортання тепер мають текст "Expand". | **Згортання всіх елементів при натисканні на кнопку "Collapse all"** | + |
| 3 | Веб-браузер | - Рендеримо компонент `<TestList />` з тестовими даними. <br> - Перевіряємо, що всі тестові елементи мають клас "collapsed". <br> - Послідовно розгортаємо кожен тестовий елемент, емітуючи кліки по їх кнопках розгортання. <br> - Також розгортаємо дочірні елементи, якщо вони є. <br> - Виконуємо повторне рендерингу компоненту, щоб відобразити зміни стану. <br> - Перевіряємо, що всі тестові елементи тепер мають клас "expanded". <br> - Перевіряємо, що кнопки розгортання тепер мають текст "Collapse". <br> - Емітуємо клік по кнопці розгортання першого елемента. <br> - Виконуємо повторне рендерингу компоненту, щоб відобразити зміни стану. <br> - Перевіряємо, що перший елемент тепер має клас "collapsed". <br> - Перевіряємо, що кнопка розгортання першого елемента тепер має текст "Expand". | **Коректне оновлення тексту кнопок при ручному розгортанні/згортанні елементів** | + |

## Integration Tests Suite 4

| # | Тестове оточення | Тест | Очікуваний результат | Висновок |
|---|------------------|------|----------------------|----------|
| 1 | Веб-браузер | - Рендеримо компонент `<SearchInput />` з порожнім значенням, обробником змін та плейсхолдером "Search microservices". <br> - Перевіряємо, що поле вводу з плейсхолдером "Search microservices" присутнє на сторінці. | **Рендеринг поля пошуку з плейсхолдером** | + |
| 2 | Веб-браузер | - Рендеримо компонент `<SearchInput />` з порожнім значенням, обробником змін `handleChange` та плейсхолдером "Search microservices". <br> - Знаходимо поле вводу за плейсхолдером. <br> - Емітуємо введення тексту "test" у поле вводу. <br> - Перевіряємо, що функція `handleChange` була викликана 4 рази (по одному на кожен символ). | **Виклик onChange при зміні значення поля вводу** | + |
| 3 | Веб-браузер | - Рендеримо компонент `<SearchInput />` з порожнім значенням, обробником змін та плейсхолдером "Search microservices". <br> - Перевіряємо, що SVG елемент з класом "lucide-search" присутній на сторінці. | **Відображення іконки пошуку** | + |
| 4 | Веб-браузер | - Рендеримо компонент `<SearchInput />` зі значенням "test value", обробником змін та плейсхолдером "Search microservices". <br> - Перевіряємо, що поле вводу з плейсхолдером "Search microservices" має значення "test value". | **Коректне встановлення значення поля вводу** | + |

## Integration Tests Suite 5

| # | Тестове оточення | Тест | Очікуваний результат | Висновок |
|---|------------------|------|----------------------|----------|
| 1 | Веб-браузер | - Рендеримо компонент `<TestList />` з вказаним microserviceId, тестовими даними та обробниками подій. <br> - Перевіряємо, що назва мікросервісу відображається на сторінці. <br> - Перевіряємо, що список тестових елементів відображається, коли мікросервіс має дочірні елементи. | **Рендеринг списку тестових елементів** | + |
| 2 | Веб-браузер | - Рендеримо компонент `<TestList />` з властивістю isExpanded="false" для тестових елементів. <br> - Перевіряємо, що деталі для згорнутих тестових елементів не відображаються. | **Не відображаються деталі для згорнутих тестових елементів** | + |
| 3 | Веб-браузер | - Рендеримо компонент `<TestList />` з порожнім масивом тестів. <br> - Перевіряємо, що відображається повідомлення про відсутність тестів. | **Відображення повідомлення, коли тести відсутні** | + |
| 4 | Веб-браузер | - Змінюємо мок `useTestItems`, щоб показував стан завантаження. <br> - Рендеримо компонент `<TestList />`. <br> - Перевіряємо, що індикатор завантаження відображається на сторінці. | **Відображення стану завантаження** | + |
| 5 | Веб-браузер | - Змінюємо мок `useTestItems`, щоб показував стан помилки. <br> - Рендеримо компонент `<TestList />`. <br> - Перевіряємо, що повідомлення про помилку відображається на сторінці. | **Відображення стану помилки** | + |
| 6 | Веб-браузер | - Змінюємо мок `useTestItems`, щоб симулювати стан елементів. <br> - Рендеримо компонент `<TestList />`. <br> - Знаходимо кнопку розгортання всіх елементів і емітуємо клік. <br> - Перевіряємо, що функція `expandAll` була викликана. <br> - Перевіряємо, що функція `showInfo` була викликана з повідомленням про розгортання всіх тестів. | **Перемикання всіх елементів при натисканні на кнопку розгортання/згортання** | + |
| 7 | Веб-браузер | - Очищаємо попередні виклики моків. <br> - Рендеримо компонент `<TestList />`. <br> - Знаходимо кнопку запуску тесту для першого елемента і емітуємо клік. <br> - Перевіряємо, що функція `onRunTest` була викликана з правильним тестом. <br> - Перевіряємо, що функція `showInfo` була викликана з повідомленням про запуск тесту. | **Запуск тесту при натисканні кнопки запуску** | + |
| 8 | Веб-браузер | - Очищаємо попередні виклики моків. <br> - Рендеримо компонент `<TestList />`. <br> - Знаходимо кнопку генерації тесту для першого елемента і емітуємо клік. <br> - Перевіряємо, що функція `onGenerateTest` була викликана з правильним тестом. <br> - Перевіряємо, що функція `showInfo` була викликана з повідомленням про генерацію тесту. | **Генерація тесту при натисканні кнопки генерації** | + |
| 9 | Веб-браузер | - Змінюємо мок `useTestItems`, щоб симулювати функціональність модального вікна. <br> - Рендеримо компонент `<TestList />` з даними результатів для першого тесту. <br> - Перевіряємо, що модальне вікно відображається з правильним вмістом. <br> - Перевіряємо, що ідентифікатор тесту відображається правильно. <br> - Перевіряємо, що вихідні дані тесту відображаються правильно. | **Відображення модального вікна результатів тесту при натисканні кнопки перегляду** | + |
